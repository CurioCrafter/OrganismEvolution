#include "ProceduralWorld.h"
#include "Terrain.h"
#include "PlanetSeed.h"
#include <chrono>
#include <algorithm>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <fstream>
#include <filesystem>

// ============================================================================
// ProceduralWorld Implementation
// ============================================================================

ProceduralWorld::ProceduralWorld()
    : m_rng(m_rd()) {
}

ProceduralWorld::~ProceduralWorld() = default;

void ProceduralWorld::reportProgress(float progress, const char* stage) const {
    if (!m_progressCallback) {
        return;
    }
    float clamped = std::clamp(progress, 0.0f, 1.0f);
    m_progressCallback(clamped, stage ? stage : "");
}

uint32_t ProceduralWorld::ensureSeed(uint32_t seed) {
    if (seed == 0) {
        // Generate time-based seed for session uniqueness
        auto now = std::chrono::high_resolution_clock::now();
        auto duration = now.time_since_epoch();
        auto millis = std::chrono::duration_cast<std::chrono::milliseconds>(duration).count();

        // Combine time with random device for maximum entropy
        uint64_t timeSeed = static_cast<uint64_t>(millis);
        uint32_t randomPart = m_rd();

        // Mix using splitmix64-like combination
        uint64_t combined = timeSeed ^ (static_cast<uint64_t>(randomPart) << 32);
        combined = (combined ^ (combined >> 30)) * 0xBF58476D1CE4E5B9ULL;
        combined = (combined ^ (combined >> 27)) * 0x94D049BB133111EBULL;
        uint32_t result = static_cast<uint32_t>((combined ^ (combined >> 31)) & 0xFFFFFFFF);

        // Ensure non-zero
        if (result == 0) result = 1;

        m_sessionSeed = result;
        m_wasAutoGenerated = true;
        return result;
    }
    m_sessionSeed = seed;
    m_wasAutoGenerated = false;
    return seed;
}

const GeneratedWorld& ProceduralWorld::generate(const WorldGenConfig& config) {
    auto startTime = std::chrono::high_resolution_clock::now();

    GeneratedWorld world;

    std::filesystem::create_directories("logs");
    std::ofstream logFile("logs/worldgen_thread.log", std::ios::app);
    auto logLine = [&](const std::string& msg) {
        if (!logFile) return;
        logFile << msg << "\n";
        logFile.flush();
    };
    logLine("==== World Generation Start ====");
    logLine("Seed: " + std::to_string(config.seed) +
            " Resolution: " + std::to_string(config.heightmapResolution) +
            " IslandShape: " + std::to_string(static_cast<int>(config.islandShape)) +
            " Regions: " + std::to_string(config.desiredRegionCount) +
            " Ocean: " + std::to_string(config.oceanCoverage));
    reportProgress(0.05f, "Preparing seeds...");

    // Ensure we have a valid seed
    uint32_t seed = ensureSeed(config.seed);
    m_lastSeed = seed;
    m_lastConfig = config;
    m_lastConfig.seed = seed;

    // Initialize planet seed system
    world.planetSeed.setMasterSeed(seed);

    // Get terrain variation from seed
    auto terrainVar = SeedVariation::TerrainVariation::fromSeed(world.planetSeed.terrainSeed);
    auto oceanVar = SeedVariation::OceanVariation::fromSeed(world.planetSeed.oceanSeed);
    auto archVar = SeedVariation::ArchipelagoVariation::fromSeed(world.planetSeed.archipelagoSeed);

    // Set up island generation parameters with seed-driven variation
    IslandGenParams islandParams;
    islandParams.shape = config.islandShape;
    islandParams.islandRadius = config.islandSize;

    // Apply seed-driven coastline variation
    islandParams.coastalIrregularity = config.coastComplexity * (0.7f + oceanVar.shorelineComplexity * 0.6f);
    islandParams.coastalErosion = terrainVar.erosionStrength;

    // Vary river and lake density based on climate seed
    auto climateVar = SeedVariation::ClimateVariation::fromSeed(world.planetSeed.climateSeed);
    float moistureFactor = climateVar.moistureBase;
    islandParams.riverDensity = config.generateRivers ? (0.2f + moistureFactor * 0.3f) : 0.0f;
    islandParams.lakeDensity = config.generateLakes ? (0.1f + moistureFactor * 0.25f) : 0.0f;
    islandParams.generateCaves = config.generateCaves;
    islandParams.seed = world.planetSeed.terrainSeed;

    // Water level from config (with seed variation)
    islandParams.waterLevel = config.oceanCoverage * (0.8f + oceanVar.coverage * 0.4f);  // Apply config + variation

    // Configure shape-specific parameters with seed variation
    switch (config.islandShape) {
        case IslandShape::ARCHIPELAGO:
            islandParams.archipelagoIslandCount = archVar.islandCount;
            islandParams.archipelagoSpread = 0.4f + archVar.sizeDispersion * 0.4f;
            break;
        case IslandShape::VOLCANIC:
            islandParams.volcanoHeight = 1.2f + terrainVar.ridgeBias * 0.6f;
            islandParams.craterSize = 0.1f + terrainVar.valleyBias * 0.1f;
            islandParams.hasLavaFlows = PlanetSeed::seedToFloat(world.planetSeed.terrainSeed) > 0.3f;
            break;
        case IslandShape::ATOLL:
            islandParams.lagoonDepth = 0.2f + archVar.lagoonProbability * 0.3f;
            islandParams.reefWidth = 0.05f + oceanVar.coralReefDensity * 0.15f;
            break;
        default:
            break;
    }

    // Vary mountainousness based on terrain seed
    islandParams.mountainousness = 0.3f + terrainVar.ridgeBias * 0.5f;

    logLine("Generating island heightmap...");
    reportProgress(0.15f, "Generating terrain...");
    // Generate the island
    world.islandData = m_islandGenerator.generate(islandParams, config.heightmapResolution, config.heightmapResolution);

    // Post-processing with seed-driven erosion parameters
    int erosionPasses = 3 + static_cast<int>(terrainVar.erosionStrength * 4.0f);
    logLine("Applying coastal erosion passes: " + std::to_string(erosionPasses));
    reportProgress(0.25f, "Applying erosion...");
    m_islandGenerator.applyCoastalErosion(world.islandData, erosionPasses);

    if (config.generateRivers) {
        logLine("Carving rivers...");
        reportProgress(0.30f, "Carving rivers...");
        m_islandGenerator.carveRivers(world.islandData);
    }
    if (config.generateLakes) {
        logLine("Creating lakes...");
        reportProgress(0.33f, "Creating lakes...");
        m_islandGenerator.createLakes(world.islandData);
    }
    if (config.generateCaves) {
        logLine("Marking cave entrances...");
        reportProgress(0.36f, "Generating caves...");
        m_islandGenerator.markCaveEntrances(world.islandData);
    }
    reportProgress(0.40f, "Generating seafloor...");
    m_islandGenerator.generateUnderwaterTerrain(world.islandData);

    int smoothPasses = 2 + static_cast<int>((1.0f - terrainVar.ridgeBias) * 3.0f);
    logLine("Smoothing coastlines: " + std::to_string(smoothPasses));
    reportProgress(0.45f, "Smoothing coastlines...");
    m_islandGenerator.smoothCoastlines(world.islandData, smoothPasses);

    // Create planet theme with weighted selection if enabled
    world.planetTheme = std::make_unique<PlanetTheme>();
    logLine("Building planet theme...");
    reportProgress(0.55f, "Building planet theme...");

    if (config.randomizeTheme) {
        // Full random theme
        world.planetTheme->generateRandom(world.planetSeed.paletteSeed);
        world.themeName = "Random Planet";
        world.themeRarity = ThemeRarity::COMMON;
    } else if (config.useWeightedThemeSelection) {
        // Use theme profile registry for weighted, varied selection
        const auto& registry = ThemeProfileRegistry::getInstance();
        const ThemeProfile& profile = registry.selectTheme(world.planetSeed.paletteSeed);

        world.planetTheme->initializePreset(profile.basePreset, world.planetSeed.paletteSeed);
        applyThemeVariation(*world.planetTheme, world.planetSeed, profile);

        world.themeName = profile.name;
        world.themeRarity = profile.rarity;
    } else {
        // Use explicit preset
        world.planetTheme->initializePreset(config.themePreset, world.planetSeed.paletteSeed);
        world.themeName = presetToString(config.themePreset);
        world.themeRarity = ThemeRarity::COMMON;
    }

    // Enforce contrast budget
    ContrastBudget::enforceContrast(
        world.planetTheme->getMutableData().terrain,
        world.planetTheme->getMutableData().atmosphere,
        0.8f
    );

    logLine("Initializing biome system...");
    logLine("  World scale: " + std::to_string(config.terrainScale) + " units");
    logLine("  Heightmap resolution: " + std::to_string(config.heightmapResolution));
    logLine("  Noise frequency: " + std::to_string(config.noiseFrequency));
    reportProgress(0.65f, "Generating biomes...");
    // Create biome system and apply theme with climate variation
    world.biomeSystem = std::make_unique<BiomeSystem>();
    world.biomeSystem->setWorldScale(config.terrainScale);
    world.biomeSystem->initializeWithTheme(*world.planetTheme);
    applyClimateVariation(*world.biomeSystem, world.planetSeed);
    applyBiomeWeights(*world.biomeSystem, config.biomeWeights);
    world.biomeSystem->generateFromIslandData(world.islandData);

    // Generate biome map texture
    reportProgress(0.72f, "Building biome map...");
    generateBiomeMapTexture();

    // Calculate statistics
    reportProgress(0.78f, "Computing statistics...");
    calculateStatistics(world);
    calculateBiomeDistribution(world);

    // Cache palette variation and terrain params for shader integration
    reportProgress(0.82f, "Finalizing palette...");
    cachePaletteVariation(world.planetSeed);
    cacheTerrainParams(world.planetSeed);
    determineVegetationPreset(world.planetSeed);
    world.vegetationConfig = m_vegetationConfig;
    // Generate planet chemistry profile
    reportProgress(0.85f, "Generating planet chemistry...");
    world.planetChemistry = PlanetChemistry::fromSeed(seed);


    // Store climate statistics
    world.averageTemperature = 15.0f + climateVar.temperatureBase;
    world.temperatureRange = climateVar.temperatureRange;
    world.averageMoisture = climateVar.moistureBase;

    // Calculate generation time
    auto endTime = std::chrono::high_resolution_clock::now();
    world.generationTimeMs = std::chrono::duration<float, std::milli>(endTime - startTime).count();

    // Log generation details
    logWorldGeneration(world);

    reportProgress(0.85f, "Finalizing world data...");
    logLine("World generation complete.");
    // Store as current world
    m_currentWorld = std::make_unique<GeneratedWorld>(std::move(world));

    return *m_currentWorld;
}

const GeneratedWorld& ProceduralWorld::generateRandom(uint32_t seed) {
    seed = ensureSeed(seed);

    WorldGenConfig config;
    config.seed = seed;
    config.islandShape = WorldGeneration::randomIslandShape(seed);
    config.themePreset = WorldGeneration::randomPlanetTheme(seed + 1);
    config.islandSize = 0.3f + (seed % 100) / 200.0f;  // 0.3 to 0.8
    config.coastComplexity = 0.2f + (seed % 50) / 100.0f;  // 0.2 to 0.7
    config.generateRivers = (seed % 3) != 0;  // 66% chance
    config.generateLakes = (seed % 4) != 0;   // 75% chance
    config.generateCaves = (seed % 5) != 0;   // 80% chance

    return generate(config);
}

const GeneratedWorld& ProceduralWorld::generatePreset(IslandShape shape, PlanetPreset theme, uint32_t seed) {
    WorldGenConfig config;
    config.seed = ensureSeed(seed);
    config.islandShape = shape;
    config.themePreset = theme;
    config.generateRivers = true;
    config.generateLakes = true;
    config.generateCaves = true;

    return generate(config);
}

const GeneratedWorld& ProceduralWorld::generateEarthLikeIsland(uint32_t seed) {
    WorldGenConfig config;
    config.seed = ensureSeed(seed);
    config.islandShape = IslandShape::IRREGULAR;
    config.themePreset = PlanetPreset::EARTH_LIKE;
    config.islandSize = 0.5f;
    config.coastComplexity = 0.4f;
    config.generateRivers = true;
    config.generateLakes = true;
    config.generateCaves = true;

    return generate(config);
}

const GeneratedWorld& ProceduralWorld::generateAlienWorld(uint32_t seed) {
    seed = ensureSeed(seed);

    // Pick a random alien theme
    std::vector<PlanetPreset> alienThemes = {
        PlanetPreset::ALIEN_PURPLE,
        PlanetPreset::ALIEN_RED,
        PlanetPreset::ALIEN_BLUE,
        PlanetPreset::BIOLUMINESCENT,
        PlanetPreset::CRYSTAL_WORLD,
        PlanetPreset::TOXIC_WORLD
    };

    WorldGenConfig config;
    config.seed = seed;
    config.islandShape = WorldGeneration::randomIslandShape(seed);
    config.themePreset = alienThemes[seed % alienThemes.size()];
    config.islandSize = 0.4f + (seed % 30) / 100.0f;
    config.coastComplexity = 0.5f;
    config.generateRivers = true;
    config.generateLakes = true;
    config.generateCaves = true;

    return generate(config);
}

const GeneratedWorld& ProceduralWorld::generateArchipelago(uint32_t seed) {
    WorldGenConfig config;
    config.seed = ensureSeed(seed);
    config.islandShape = IslandShape::ARCHIPELAGO;
    config.themePreset = PlanetPreset::OCEAN_WORLD;
    config.islandSize = 0.6f;
    config.coastComplexity = 0.5f;
    config.generateRivers = true;
    config.generateLakes = true;
    config.generateCaves = false;

    return generate(config);
}

const GeneratedWorld& ProceduralWorld::generateVolcanicIsland(uint32_t seed) {
    WorldGenConfig config;
    config.seed = ensureSeed(seed);
    config.islandShape = IslandShape::VOLCANIC;
    config.themePreset = PlanetPreset::VOLCANIC_WORLD;
    config.islandSize = 0.4f;
    config.coastComplexity = 0.3f;
    config.generateRivers = true;
    config.generateLakes = true;  // Crater lakes
    config.generateCaves = true;

    return generate(config);
}

const std::vector<float>& ProceduralWorld::getHeightmap() const {
    static std::vector<float> empty;
    if (!m_currentWorld) return empty;
    return m_currentWorld->islandData.heightmap;
}

const std::vector<uint8_t>& ProceduralWorld::getBiomeMapRGBA() const {
    return m_biomeMapRGBA;
}

void ProceduralWorld::applyToTerrain(Terrain* terrain) {
    if (!m_currentWorld || !terrain) return;

    // The terrain system will use our heightmap data
    // This is a simplified integration - the actual implementation
    // would copy the heightmap to the terrain's internal buffer
    // and trigger a mesh regeneration

    // For now, we trigger a regeneration with the same seed
    terrain->generate(m_lastSeed);
}

void ProceduralWorld::applyThemeToRenderers() {
    if (!m_currentWorld || !m_currentWorld->planetTheme) return;

    // This would update shader constants for:
    // - Terrain renderer
    // - Water renderer
    // - Vegetation renderer
    // - Creature renderer
    // - Post-processing

    // The actual implementation would get the shader constants
    // and upload them to the GPU constant buffer
    auto constants = m_currentWorld->planetTheme->getShaderConstants();
    (void)constants;  // Use to update renderers
}

const GeneratedWorld& ProceduralWorld::regenerate() {
    if (m_lastSeed == 0) {
        return generateRandom();
    }

    // Generate new seed based on old one
    m_lastConfig.seed = m_lastSeed + 1;
    return generate(m_lastConfig);
}

void ProceduralWorld::generateBiomeMapTexture() {
    if (!m_currentWorld || !m_currentWorld->biomeSystem) return;

    int width = m_currentWorld->biomeSystem->getWidth();
    int height = m_currentWorld->biomeSystem->getHeight();

    m_biomeMapRGBA.resize(width * height * 4);

    for (int y = 0; y < height; ++y) {
        for (int x = 0; x < width; ++x) {
            const BiomeCell& cell = m_currentWorld->biomeSystem->getCell(x, y);

            int idx = (y * width + x) * 4;
            // R = primary biome (0-31 mapped to 0-255)
            m_biomeMapRGBA[idx + 0] = static_cast<uint8_t>(cell.primaryBiome) * 8;
            // G = secondary biome
            m_biomeMapRGBA[idx + 1] = static_cast<uint8_t>(cell.secondaryBiome) * 8;
            // B = blend factor (0-1 mapped to 0-255)
            m_biomeMapRGBA[idx + 2] = static_cast<uint8_t>(cell.blendFactor * 255.0f);
            // A = flags (reserved)
            m_biomeMapRGBA[idx + 3] = 255;
        }
    }
}

void ProceduralWorld::calculateStatistics(GeneratedWorld& world) {
    const auto& heightmap = world.islandData.heightmap;
    int size = world.islandData.width * world.islandData.height;
    float waterLevel = world.islandData.params.waterLevel;

    int landCount = 0;
    float totalElevation = 0.0f;

    for (int i = 0; i < size; ++i) {
        if (heightmap[i] > waterLevel) {
            landCount++;
            totalElevation += heightmap[i];
        }
    }

    world.landPercentage = static_cast<float>(landCount) / size * 100.0f;
    world.waterPercentage = 100.0f - world.landPercentage;
    world.averageElevation = landCount > 0 ? totalElevation / landCount : 0.0f;
    world.riverCount = static_cast<int>(world.islandData.rivers.size());
    world.lakeCount = static_cast<int>(world.islandData.lakes.size());
    world.caveCount = static_cast<int>(world.islandData.caveEntrances.size());
}

// ============================================================================
// WorldGeneration Namespace Helpers
// ============================================================================

namespace WorldGeneration {

WorldGenConfig parseDescription(const std::string& description) {
    WorldGenConfig config;

    // Simple keyword matching
    std::string lower = description;
    std::transform(lower.begin(), lower.end(), lower.begin(), ::tolower);

    // Shape detection
    if (lower.find("archipelago") != std::string::npos) {
        config.islandShape = IslandShape::ARCHIPELAGO;
    } else if (lower.find("volcanic") != std::string::npos || lower.find("volcano") != std::string::npos) {
        config.islandShape = IslandShape::VOLCANIC;
    } else if (lower.find("atoll") != std::string::npos) {
        config.islandShape = IslandShape::ATOLL;
    } else if (lower.find("crescent") != std::string::npos) {
        config.islandShape = IslandShape::CRESCENT;
    } else if (lower.find("circular") != std::string::npos || lower.find("round") != std::string::npos) {
        config.islandShape = IslandShape::CIRCULAR;
    } else if (lower.find("continental") != std::string::npos || lower.find("large") != std::string::npos) {
        config.islandShape = IslandShape::CONTINENTAL;
    }

    // Theme detection
    if (lower.find("purple") != std::string::npos) {
        config.themePreset = PlanetPreset::ALIEN_PURPLE;
    } else if (lower.find("red") != std::string::npos) {
        config.themePreset = PlanetPreset::ALIEN_RED;
    } else if (lower.find("blue") != std::string::npos && lower.find("alien") != std::string::npos) {
        config.themePreset = PlanetPreset::ALIEN_BLUE;
    } else if (lower.find("frozen") != std::string::npos || lower.find("ice") != std::string::npos) {
        config.themePreset = PlanetPreset::FROZEN_WORLD;
    } else if (lower.find("desert") != std::string::npos) {
        config.themePreset = PlanetPreset::DESERT_WORLD;
    } else if (lower.find("ocean") != std::string::npos || lower.find("tropical") != std::string::npos) {
        config.themePreset = PlanetPreset::OCEAN_WORLD;
    } else if (lower.find("lava") != std::string::npos) {
        config.themePreset = PlanetPreset::VOLCANIC_WORLD;
    } else if (lower.find("glow") != std::string::npos || lower.find("bioluminescent") != std::string::npos) {
        config.themePreset = PlanetPreset::BIOLUMINESCENT;
    } else if (lower.find("crystal") != std::string::npos) {
        config.themePreset = PlanetPreset::CRYSTAL_WORLD;
    } else if (lower.find("toxic") != std::string::npos || lower.find("poison") != std::string::npos) {
        config.themePreset = PlanetPreset::TOXIC_WORLD;
    } else if (lower.find("ancient") != std::string::npos || lower.find("old") != std::string::npos) {
        config.themePreset = PlanetPreset::ANCIENT_WORLD;
    } else if (lower.find("random") != std::string::npos || lower.find("alien") != std::string::npos) {
        config.randomizeTheme = true;
    }

    return config;
}

IslandShape randomIslandShape(uint32_t seed) {
    std::mt19937 rng(seed);
    std::uniform_int_distribution<int> dist(0, 6);

    switch (dist(rng)) {
        case 0: return IslandShape::CIRCULAR;
        case 1: return IslandShape::ARCHIPELAGO;
        case 2: return IslandShape::CRESCENT;
        case 3: return IslandShape::IRREGULAR;
        case 4: return IslandShape::VOLCANIC;
        case 5: return IslandShape::ATOLL;
        case 6: return IslandShape::CONTINENTAL;
        default: return IslandShape::IRREGULAR;
    }
}

PlanetPreset randomPlanetTheme(uint32_t seed) {
    std::mt19937 rng(seed);
    std::uniform_int_distribution<int> dist(0, 11);

    switch (dist(rng)) {
        case 0: return PlanetPreset::EARTH_LIKE;
        case 1: return PlanetPreset::ALIEN_PURPLE;
        case 2: return PlanetPreset::ALIEN_RED;
        case 3: return PlanetPreset::ALIEN_BLUE;
        case 4: return PlanetPreset::FROZEN_WORLD;
        case 5: return PlanetPreset::DESERT_WORLD;
        case 6: return PlanetPreset::OCEAN_WORLD;
        case 7: return PlanetPreset::VOLCANIC_WORLD;
        case 8: return PlanetPreset::BIOLUMINESCENT;
        case 9: return PlanetPreset::CRYSTAL_WORLD;
        case 10: return PlanetPreset::TOXIC_WORLD;
        case 11: return PlanetPreset::ANCIENT_WORLD;
        default: return PlanetPreset::EARTH_LIKE;
    }
}

std::vector<WorldPreset> getCuratedPresets() {
    return {
        {"Tropical Paradise", IslandShape::IRREGULAR, PlanetPreset::OCEAN_WORLD, 0.4f, true, true},
        {"Volcanic Caldera", IslandShape::VOLCANIC, PlanetPreset::VOLCANIC_WORLD, 0.3f, true, true},
        {"Mystic Archipelago", IslandShape::ARCHIPELAGO, PlanetPreset::ALIEN_PURPLE, 0.5f, true, true},
        {"Frozen North", IslandShape::CONTINENTAL, PlanetPreset::FROZEN_WORLD, 0.6f, true, true},
        {"Desert Oasis", IslandShape::CIRCULAR, PlanetPreset::DESERT_WORLD, 0.2f, true, true},
        {"Bioluminescent Reef", IslandShape::ATOLL, PlanetPreset::BIOLUMINESCENT, 0.4f, false, false},
        {"Crystal Spires", IslandShape::IRREGULAR, PlanetPreset::CRYSTAL_WORLD, 0.7f, true, true},
        {"Toxic Wasteland", IslandShape::CRESCENT, PlanetPreset::TOXIC_WORLD, 0.5f, true, false},
        {"Ancient Ruins", IslandShape::CONTINENTAL, PlanetPreset::ANCIENT_WORLD, 0.4f, true, true},
        {"Red Alien World", IslandShape::IRREGULAR, PlanetPreset::ALIEN_RED, 0.5f, true, true},
        {"Blue Twilight", IslandShape::ARCHIPELAGO, PlanetPreset::ALIEN_BLUE, 0.4f, true, true},
        {"Earth Prime", IslandShape::CONTINENTAL, PlanetPreset::EARTH_LIKE, 0.5f, true, true}
    };
}

WorldPreset getRandomPreset(uint32_t seed) {
    auto presets = getCuratedPresets();
    std::mt19937 rng(seed);
    std::uniform_int_distribution<size_t> dist(0, presets.size() - 1);
    return presets[dist(rng)];
}

}  // namespace WorldGeneration

// ============================================================================
// New methods for run-to-run uniqueness
// ============================================================================

std::string ProceduralWorld::getSeedFingerprint() const {
    if (m_currentWorld) {
        return m_currentWorld->planetSeed.fingerprint;
    }
    return "N/A";
}

void ProceduralWorld::applyThemeVariation(PlanetTheme& theme, const PlanetSeed& seed, const ThemeProfile& profile) {
    auto& data = theme.getMutableData();
    const auto& ranges = profile.ranges;

    // HSV utility lambdas
    auto hsvToRgb = [](float h, float s, float v) -> glm::vec3 {
        float c = v * s;
        float x = c * (1.0f - std::abs(std::fmod(h / 60.0f, 2.0f) - 1.0f));
        float m = v - c;

        glm::vec3 rgb;
        if (h < 60) rgb = {c, x, 0};
        else if (h < 120) rgb = {x, c, 0};
        else if (h < 180) rgb = {0, c, x};
        else if (h < 240) rgb = {0, x, c};
        else if (h < 300) rgb = {x, 0, c};
        else rgb = {c, 0, x};

        return rgb + glm::vec3(m);
    };

    // Derive variation values from seed
    float skyHue = PlanetSeed::seedToRange(PlanetSeed::getSubSeed(seed.paletteSeed, 0), ranges.skyHueMin, ranges.skyHueMax);
    float skySat = PlanetSeed::seedToRange(PlanetSeed::getSubSeed(seed.paletteSeed, 1), ranges.skySatMin, ranges.skySatMax);
    float skyBright = PlanetSeed::seedToRange(PlanetSeed::getSubSeed(seed.paletteSeed, 2), ranges.skyBrightMin, ranges.skyBrightMax);

    float fogDensity = PlanetSeed::seedToRange(PlanetSeed::getSubSeed(seed.paletteSeed, 3), ranges.fogDensityMin, ranges.fogDensityMax);
    float fogDistance = PlanetSeed::seedToRange(PlanetSeed::getSubSeed(seed.paletteSeed, 4), ranges.fogDistanceMin, ranges.fogDistanceMax);

    float waterHue = PlanetSeed::seedToRange(PlanetSeed::getSubSeed(seed.paletteSeed, 5), ranges.waterHueMin, ranges.waterHueMax);
    float waterClarity = PlanetSeed::seedToRange(PlanetSeed::getSubSeed(seed.paletteSeed, 6), ranges.waterClarityMin, ranges.waterClarityMax);

    float sunHue = PlanetSeed::seedToRange(PlanetSeed::getSubSeed(seed.paletteSeed, 7), ranges.sunHueMin, ranges.sunHueMax);
    float sunIntensity = PlanetSeed::seedToRange(PlanetSeed::getSubSeed(seed.paletteSeed, 8), ranges.sunIntensityMin, ranges.sunIntensityMax);

    float biomeSat = PlanetSeed::seedToRange(PlanetSeed::getSubSeed(seed.paletteSeed, 9), ranges.biomeSaturationMin, ranges.biomeSaturationMax);
    float warmth = PlanetSeed::seedToRange(PlanetSeed::getSubSeed(seed.paletteSeed, 10), ranges.warmthMin, ranges.warmthMax);

    // Apply sky variation
    data.atmosphere.skyZenithColor = hsvToRgb(skyHue, skySat, skyBright);
    data.atmosphere.skyHorizonColor = hsvToRgb(skyHue + 15.0f, skySat * 0.7f, skyBright * 1.1f);
    data.atmosphere.fogColor = data.atmosphere.skyHorizonColor * 0.8f;
    data.atmosphere.fogDensity = fogDensity;
    data.atmosphere.fogStart = fogDistance;

    // Apply sun variation
    data.atmosphere.sunColor = hsvToRgb(sunHue, 0.3f, 1.0f);
    data.atmosphere.sunIntensity = sunIntensity;

    // Apply water variation
    // Handle hue wrap-around for water
    float effectiveWaterHue = waterHue;
    if (ranges.waterHueMin > ranges.waterHueMax) {
        // Range crosses 0/360 boundary
        float range = (360.0f - ranges.waterHueMin) + ranges.waterHueMax;
        float t = PlanetSeed::seedToFloat(PlanetSeed::getSubSeed(seed.paletteSeed, 5));
        effectiveWaterHue = std::fmod(ranges.waterHueMin + t * range, 360.0f);
    }
    data.terrain.deepWaterColor = hsvToRgb(effectiveWaterHue, 0.6f, 0.3f + waterClarity * 0.2f);
    data.terrain.shallowWaterColor = hsvToRgb(effectiveWaterHue, 0.4f, 0.5f + waterClarity * 0.3f);

    // Apply warmth shift to vegetation
    auto applyWarmth = [warmth](glm::vec3& color) {
        if (warmth > 0) {
            color.r = std::min(1.0f, color.r + warmth * 0.1f);
            color.b = std::max(0.0f, color.b - warmth * 0.1f);
        } else {
            color.r = std::max(0.0f, color.r + warmth * 0.1f);
            color.b = std::min(1.0f, color.b - warmth * 0.1f);
        }
    };

    applyWarmth(data.terrain.grassColor);
    applyWarmth(data.terrain.forestColor);
    applyWarmth(data.terrain.shrubColor);

    // Apply saturation variation to all terrain colors
    auto applySaturation = [biomeSat](glm::vec3& color) {
        float gray = 0.299f * color.r + 0.587f * color.g + 0.114f * color.b;
        color = glm::mix(glm::vec3(gray), color, biomeSat);
    };

    applySaturation(data.terrain.grassColor);
    applySaturation(data.terrain.forestColor);
    applySaturation(data.terrain.sandColor);
    applySaturation(data.terrain.dirtColor);
    applySaturation(data.terrain.shrubColor);

    data.vegetation.colorSaturation = biomeSat;

    // Copy atmosphere to time-of-day variants
    data.atmosphereNoon = data.atmosphere;

    data.atmosphereDawn = data.atmosphere;
    data.atmosphereDawn.skyHorizonColor = hsvToRgb(sunHue + 10.0f, skySat * 0.8f, skyBright * 0.9f);
    data.atmosphereDawn.sunIntensity = sunIntensity * 0.6f;

    data.atmosphereDusk = data.atmosphere;
    data.atmosphereDusk.skyHorizonColor = hsvToRgb(sunHue - 10.0f, skySat * 0.9f, skyBright * 0.7f);
    data.atmosphereDusk.sunIntensity = sunIntensity * 0.5f;

    data.atmosphereNight = data.atmosphere;
    data.atmosphereNight.skyZenithColor = data.atmosphere.skyZenithColor * 0.1f;
    data.atmosphereNight.skyHorizonColor = data.atmosphere.skyHorizonColor * 0.15f;
    data.atmosphereNight.sunIntensity = 0.0f;
    data.atmosphereNight.moonIntensity = 0.3f;
}

void ProceduralWorld::calculateBiomeDistribution(GeneratedWorld& world) {
    if (!world.biomeSystem) {
        world.desertCoverage = 0.0f;
        world.forestCoverage = 0.0f;
        world.tundraCoverage = 0.0f;
        world.tropicalCoverage = 0.0f;
        world.wetlandCoverage = 0.0f;
        world.mountainCoverage = 0.0f;
        return;
    }

    int width = world.biomeSystem->getWidth();
    int height = world.biomeSystem->getHeight();
    int totalLand = 0;
    int desertCount = 0, forestCount = 0, tundraCount = 0;
    int tropicalCount = 0, wetlandCount = 0, mountainCount = 0;

    for (int y = 0; y < height; ++y) {
        for (int x = 0; x < width; ++x) {
            const BiomeCell& cell = world.biomeSystem->getCell(x, y);
            BiomeType biome = cell.primaryBiome;

            // Skip water biomes
            if (biome == BiomeType::DEEP_OCEAN ||
                biome == BiomeType::OCEAN ||
                biome == BiomeType::SHALLOW_WATER ||
                biome == BiomeType::CORAL_REEF ||
                biome == BiomeType::KELP_FOREST) {
                continue;
            }

            totalLand++;

            // Categorize by biome type
            switch (biome) {
                case BiomeType::DESERT_HOT:
                case BiomeType::DESERT_COLD:
                    desertCount++;
                    break;
                case BiomeType::TEMPERATE_FOREST:
                case BiomeType::BOREAL_FOREST:
                case BiomeType::MOUNTAIN_FOREST:
                    forestCount++;
                    break;
                case BiomeType::TUNDRA:
                case BiomeType::GLACIER:
                    tundraCount++;
                    break;
                case BiomeType::TROPICAL_RAINFOREST:
                case BiomeType::SAVANNA:
                    tropicalCount++;
                    break;
                case BiomeType::SWAMP:
                case BiomeType::WETLAND:
                case BiomeType::MANGROVE:
                case BiomeType::SALT_MARSH:
                    wetlandCount++;
                    break;
                case BiomeType::ROCKY_HIGHLANDS:
                case BiomeType::ALPINE_MEADOW:
                case BiomeType::VOLCANIC:
                case BiomeType::LAVA_FIELD:
                    mountainCount++;
                    break;
                default:
                    break;
            }
        }
    }

    if (totalLand > 0) {
        world.desertCoverage = static_cast<float>(desertCount) / totalLand * 100.0f;
        world.forestCoverage = static_cast<float>(forestCount) / totalLand * 100.0f;
        world.tundraCoverage = static_cast<float>(tundraCount) / totalLand * 100.0f;
        world.tropicalCoverage = static_cast<float>(tropicalCount) / totalLand * 100.0f;
        world.wetlandCoverage = static_cast<float>(wetlandCount) / totalLand * 100.0f;
        world.mountainCoverage = static_cast<float>(mountainCount) / totalLand * 100.0f;
    }
}

void ProceduralWorld::applyClimateVariation(BiomeSystem& biomeSystem, const PlanetSeed& seed) {
    auto climateVar = SeedVariation::ClimateVariation::fromSeed(seed.climateSeed);

    // Set up climate zones based on seed
    std::vector<ClimateZone> zones;

    // Polar zone (cold)
    ClimateZone polar;
    polar.latitudeStart = -1.0f;
    polar.latitudeEnd = -0.7f + climateVar.temperatureBase * 0.02f;
    polar.baseTemperature = -0.8f;
    polar.baseMoisture = 0.2f;
    polar.temperatureVariation = 0.1f;
    polar.moistureVariation = 0.1f;
    zones.push_back(polar);

    // Temperate zone
    ClimateZone temperate;
    temperate.latitudeStart = polar.latitudeEnd;
    temperate.latitudeEnd = 0.3f + climateVar.temperatureBase * 0.02f;
    temperate.baseTemperature = 0.0f + climateVar.temperatureBase * 0.02f;
    temperate.baseMoisture = climateVar.moistureBase;
    temperate.temperatureVariation = 0.2f;
    temperate.moistureVariation = climateVar.moistureRange * 0.5f;
    zones.push_back(temperate);

    // Tropical zone (warm)
    ClimateZone tropical;
    tropical.latitudeStart = temperate.latitudeEnd;
    tropical.latitudeEnd = 1.0f;
    tropical.baseTemperature = 0.6f + climateVar.temperatureBase * 0.01f;
    tropical.baseMoisture = climateVar.moistureBase + 0.2f;
    tropical.temperatureVariation = 0.1f;
    tropical.moistureVariation = 0.3f;
    zones.push_back(tropical);

    biomeSystem.setClimateZones(zones);
}

void ProceduralWorld::applyBiomeWeights(BiomeSystem& biomeSystem, const BiomeWeights& weights) {
    // Apply biome weight overrides to biome properties
    // Weights affect the vegetation density and spawn rates for each biome type

    auto scaleVegetation = [](BiomeProperties& props, float weight) {
        props.treeDensity *= weight;
        props.grassDensity *= weight;
        props.shrubDensity *= weight;
    };

    // Forest biomes
    if (weights.forestWeight != 1.0f) {
        auto& tempForest = biomeSystem.getMutableProperties(BiomeType::TEMPERATE_FOREST);
        scaleVegetation(tempForest, weights.forestWeight);

        auto& borealForest = biomeSystem.getMutableProperties(BiomeType::BOREAL_FOREST);
        scaleVegetation(borealForest, weights.forestWeight);

        auto& tropicalForest = biomeSystem.getMutableProperties(BiomeType::TROPICAL_RAINFOREST);
        scaleVegetation(tropicalForest, weights.forestWeight);
    }

    // Grassland biomes
    if (weights.grasslandWeight != 1.0f) {
        auto& savanna = biomeSystem.getMutableProperties(BiomeType::SAVANNA);
        scaleVegetation(savanna, weights.grasslandWeight);

        auto& grassland = biomeSystem.getMutableProperties(BiomeType::GRASSLAND);
        scaleVegetation(grassland, weights.grasslandWeight);
    }

    // Desert biomes
    if (weights.desertWeight != 1.0f) {
        auto& hotDesert = biomeSystem.getMutableProperties(BiomeType::DESERT_HOT);
        scaleVegetation(hotDesert, weights.desertWeight);

        auto& coldDesert = biomeSystem.getMutableProperties(BiomeType::DESERT_COLD);
        scaleVegetation(coldDesert, weights.desertWeight);
    }

    // Tundra biomes
    if (weights.tundraWeight != 1.0f) {
        auto& tundra = biomeSystem.getMutableProperties(BiomeType::TUNDRA);
        scaleVegetation(tundra, weights.tundraWeight);
    }

    // Wetland biomes
    if (weights.wetlandWeight != 1.0f) {
        auto& swamp = biomeSystem.getMutableProperties(BiomeType::SWAMP);
        scaleVegetation(swamp, weights.wetlandWeight);

        auto& wetland = biomeSystem.getMutableProperties(BiomeType::WETLAND);
        scaleVegetation(wetland, weights.wetlandWeight);

        auto& mangrove = biomeSystem.getMutableProperties(BiomeType::MANGROVE);
        scaleVegetation(mangrove, weights.wetlandWeight);
    }

    // Mountain biomes
    if (weights.mountainWeight != 1.0f) {
        auto& rocky = biomeSystem.getMutableProperties(BiomeType::ROCKY_HIGHLANDS);
        scaleVegetation(rocky, weights.mountainWeight);

        auto& alpine = biomeSystem.getMutableProperties(BiomeType::ALPINE_MEADOW);
        scaleVegetation(alpine, weights.mountainWeight);
    }

    // Volcanic biomes
    if (weights.volcanicWeight != 1.0f) {
        auto& volcanic = biomeSystem.getMutableProperties(BiomeType::VOLCANIC);
        scaleVegetation(volcanic, weights.volcanicWeight);

        auto& lavaField = biomeSystem.getMutableProperties(BiomeType::LAVA_FIELD);
        scaleVegetation(lavaField, weights.volcanicWeight);
    }
}

void ProceduralWorld::logWorldGeneration(const GeneratedWorld& world) const {
    // Rarity string lookup
    const char* rarityStr = "Common";
    switch (world.themeRarity) {
        case ThemeRarity::UNCOMMON: rarityStr = "Uncommon"; break;
        case ThemeRarity::RARE: rarityStr = "Rare"; break;
        case ThemeRarity::LEGENDARY: rarityStr = "Legendary"; break;
        default: break;
    }

    // Vegetation preset string
    const char* vegStr = "Default";
    switch (m_vegetationConfig.preset) {
        case VegetationPreset::SPARSE: vegStr = "Sparse"; break;
        case VegetationPreset::LUSH: vegStr = "Lush"; break;
        case VegetationPreset::ALIEN: vegStr = "Alien"; break;
        case VegetationPreset::DEAD: vegStr = "Dead"; break;
        case VegetationPreset::OVERGROWN: vegStr = "Overgrown"; break;
        default: break;
    }

    std::cout << "\n========== WORLD GENERATION COMPLETE ==========\n";
    std::cout << "  Seed: " << world.planetSeed.masterSeed << " [" << world.planetSeed.fingerprint << "]";
    if (m_wasAutoGenerated) {
        std::cout << " (Auto-generated)";
    }
    std::cout << "\n";
    std::cout << "  Theme: " << world.themeName << " (" << rarityStr << ")\n";
    std::cout << "  Vegetation: " << vegStr << " (density: " << std::fixed << std::setprecision(2)
              << m_cachedPaletteVariation.vegetationDensity << ")\n";
    std::cout << "  Land: " << std::setprecision(1) << world.landPercentage << "% | Water: " << world.waterPercentage << "%\n";
    std::cout << "  Rivers: " << world.riverCount << " | Lakes: " << world.lakeCount << " | Caves: " << world.caveCount << "\n";
    std::cout << "  Climate: " << std::setprecision(1) << world.averageTemperature << "C avg, " << world.temperatureRange << "C range\n";
    std::cout << "  Biomes: Desert " << std::setprecision(0) << world.desertCoverage << "% | Forest " << world.forestCoverage
              << "% | Tundra " << world.tundraCoverage << "% | Tropical " << world.tropicalCoverage << "%\n";
    std::cout << "  Palette: warmth=" << std::setprecision(2) << m_cachedPaletteVariation.warmth
              << ", sat=" << m_cachedPaletteVariation.biomeSaturation
              << ", fog=" << m_cachedPaletteVariation.fogDensity << "\n";

    // Planet chemistry logging
    std::cout << "\n  === Planet Chemistry ===\n";
    std::cout << "  Profile: " << world.planetChemistry.getProfileName() << "\n";
    std::cout << "  Solvent: " << getSolventName(world.planetChemistry.solventType) << "\n";
    std::cout << "  Atmosphere: O2=" << std::setprecision(1) << (world.planetChemistry.atmosphere.oxygen * 100.0f)
              << "%, N2=" << (world.planetChemistry.atmosphere.nitrogen * 100.0f)
              << "%, CO2=" << std::setprecision(2) << (world.planetChemistry.atmosphere.carbonDioxide * 100.0f)
              << "% (" << std::setprecision(2) << world.planetChemistry.atmosphere.pressure << " atm)\n";
    std::cout << "  Temperature: " << std::setprecision(0) << world.planetChemistry.temperatureBase
              << "C +/- " << world.planetChemistry.temperatureRange << "C\n";
    std::cout << "  pH: " << std::setprecision(1) << world.planetChemistry.acidity
              << " | Radiation: " << std::setprecision(2) << world.planetChemistry.radiationLevel << "x Earth\n";
    std::cout << "  Dominant Mineral: " << world.planetChemistry.minerals.getDominantMineral() << "\n";

    std::cout << "\n  Generation Time: " << std::setprecision(1) << world.generationTimeMs << " ms\n";
    std::cout << "================================================\n\n";
}

// ============================================================================
// Session Seed and Shader Integration Methods
// ============================================================================

std::string ProceduralWorld::getFullSeedInfo() const {
    if (!m_currentWorld) return "No world generated";

    std::ostringstream ss;
    ss << m_currentWorld->planetSeed.masterSeed
       << " [" << m_currentWorld->planetSeed.fingerprint << "]";
    if (m_wasAutoGenerated) {
        ss << " (Session Auto)";
    }
    return ss.str();
}

void ProceduralWorld::cachePaletteVariation(const PlanetSeed& seed) {
    // Use the palette seed to derive all variation values
    m_cachedPaletteVariation.skyHue = PlanetSeed::seedToRange(
        PlanetSeed::getSubSeed(seed.paletteSeed, 0), 0.0f, 360.0f);
    m_cachedPaletteVariation.skySaturation = PlanetSeed::seedToRange(
        PlanetSeed::getSubSeed(seed.paletteSeed, 1), 0.5f, 1.2f);
    m_cachedPaletteVariation.skyBrightness = PlanetSeed::seedToRange(
        PlanetSeed::getSubSeed(seed.paletteSeed, 2), 0.7f, 1.3f);
    m_cachedPaletteVariation.fogDensity = PlanetSeed::seedToRange(
        PlanetSeed::getSubSeed(seed.paletteSeed, 3), 0.01f, 0.05f);
    m_cachedPaletteVariation.fogDistance = PlanetSeed::seedToRange(
        PlanetSeed::getSubSeed(seed.paletteSeed, 4), 50.0f, 150.0f);
    m_cachedPaletteVariation.waterHue = PlanetSeed::seedToRange(
        PlanetSeed::getSubSeed(seed.paletteSeed, 5), 180.0f, 240.0f);
    m_cachedPaletteVariation.waterClarity = PlanetSeed::seedToRange(
        PlanetSeed::getSubSeed(seed.paletteSeed, 6), 0.3f, 0.9f);
    m_cachedPaletteVariation.sunHue = PlanetSeed::seedToRange(
        PlanetSeed::getSubSeed(seed.paletteSeed, 7), 30.0f, 60.0f);
    m_cachedPaletteVariation.sunIntensity = PlanetSeed::seedToRange(
        PlanetSeed::getSubSeed(seed.paletteSeed, 8), 0.8f, 1.2f);
    m_cachedPaletteVariation.biomeSaturation = PlanetSeed::seedToRange(
        PlanetSeed::getSubSeed(seed.paletteSeed, 9), 0.7f, 1.3f);
    m_cachedPaletteVariation.warmth = PlanetSeed::seedToRange(
        PlanetSeed::getSubSeed(seed.paletteSeed, 10), -0.5f, 0.5f);
    m_cachedPaletteVariation.vegetationDensity = PlanetSeed::seedToRange(
        PlanetSeed::getSubSeed(seed.vegetationSeed, 0), 0.5f, 1.5f);
}

void ProceduralWorld::cacheTerrainParams(const PlanetSeed& seed) {
    auto terrainVar = SeedVariation::TerrainVariation::fromSeed(seed.terrainSeed);

    m_cachedTerrainParams.erosionStrength = terrainVar.erosionStrength;
    m_cachedTerrainParams.ridginess = terrainVar.ridgeBias;
    m_cachedTerrainParams.valleyDepth = terrainVar.valleyBias;
    m_cachedTerrainParams.noiseFrequency = terrainVar.noiseFrequency;
    m_cachedTerrainParams.noiseOctaves = terrainVar.noiseOctaves;
}

void ProceduralWorld::determineVegetationPreset(const PlanetSeed& seed) {
    m_vegetationConfig = VegetationDensityConfig::fromSeed(seed.vegetationSeed);

    float densityScale = (m_vegetationConfig.treeDensity +
                          m_vegetationConfig.grassDensity +
                          m_vegetationConfig.shrubDensity) / 3.0f;
    m_cachedPaletteVariation.vegetationDensity *= densityScale;
}

ProceduralWorld::PaletteVariation ProceduralWorld::getCurrentPaletteVariation() const {
    return m_cachedPaletteVariation;
}

ProceduralWorld::TerrainShaderParams ProceduralWorld::getTerrainShaderParams() const {
    return m_cachedTerrainParams;
}

const VegetationDensityConfig& ProceduralWorld::getVegetationConfig() const {
    return m_vegetationConfig;
}

ProceduralWorld::StarShaderParams ProceduralWorld::getStarShaderParams() const {
    return m_cachedStarParams;
}

const StarType& ProceduralWorld::getCurrentStarType() const {
    static StarType defaultStar;
    if (m_currentWorld) {
        return m_currentWorld->starType;
    }
    return defaultStar;
}

const RegionConfig* ProceduralWorld::getRegionConfig(int islandId) const {
    if (!m_currentWorld) return nullptr;
    return m_currentWorld->multiRegion.getRegionForIsland(islandId);
}

const MultiRegionConfig& ProceduralWorld::getMultiRegionConfig() const {
    static MultiRegionConfig emptyConfig;
    if (m_currentWorld) {
        return m_currentWorld->multiRegion;
    }
    return emptyConfig;
}

int ProceduralWorld::getRegionAtPosition(const glm::vec3& worldPos) const {
    // Find nearest island and return its region
    if (!m_currentWorld || m_currentWorld->multiRegion.regions.empty()) return -1;
    if (m_currentWorld->multiRegion.regions.size() == 1) {
        return m_currentWorld->multiRegion.regions.front().regionId;
    }
    (void)worldPos;
    // TODO: IslandGenerator doesn't expose island positions for mapping yet.
    return -1;
}

// ============================================================================
// StarType Implementation
// ============================================================================

StarType StarType::fromSeed(uint32_t seed) {
    StarType star;

    // Determine spectral class from seed (weighted distribution)
    float classRoll = PlanetSeed::seedToFloat(seed);
    if (classRoll < 0.01f) {
        star.spectralClass = StarSpectralClass::O_BLUE_GIANT;
    } else if (classRoll < 0.03f) {
        star.spectralClass = StarSpectralClass::B_BLUE;
    } else if (classRoll < 0.08f) {
        star.spectralClass = StarSpectralClass::A_WHITE;
    } else if (classRoll < 0.20f) {
        star.spectralClass = StarSpectralClass::F_YELLOW_WHITE;
    } else if (classRoll < 0.50f) {
        star.spectralClass = StarSpectralClass::G_YELLOW;
    } else if (classRoll < 0.75f) {
        star.spectralClass = StarSpectralClass::K_ORANGE;
    } else if (classRoll < 0.95f) {
        star.spectralClass = StarSpectralClass::M_RED_DWARF;
    } else if (classRoll < 0.97f) {
        star.spectralClass = StarSpectralClass::BINARY_SYSTEM;
    } else if (classRoll < 0.99f) {
        star.spectralClass = StarSpectralClass::RED_GIANT;
    } else {
        star.spectralClass = StarSpectralClass::WHITE_DWARF;
    }

    // Set properties based on spectral class
    switch (star.spectralClass) {
        case StarSpectralClass::O_BLUE_GIANT:
            star.color = glm::vec3(0.6f, 0.7f, 1.0f);
            star.intensity = 2.0f;
            star.temperature = 30000.0f;
            star.angularSize = 0.8f;
            star.temperatureOffset = 15.0f;
            star.uvIntensity = 3.0f;
            star.skyTintModifier = glm::vec3(0.8f, 0.9f, 1.2f);
            star.twilightDuration = 0.7f;
            break;
        case StarSpectralClass::B_BLUE:
            star.color = glm::vec3(0.7f, 0.8f, 1.0f);
            star.intensity = 1.6f;
            star.temperature = 15000.0f;
            star.angularSize = 0.85f;
            star.temperatureOffset = 8.0f;
            star.uvIntensity = 2.0f;
            star.skyTintModifier = glm::vec3(0.85f, 0.92f, 1.15f);
            star.twilightDuration = 0.8f;
            break;
        case StarSpectralClass::A_WHITE:
            star.color = glm::vec3(0.9f, 0.95f, 1.0f);
            star.intensity = 1.3f;
            star.temperature = 8500.0f;
            star.angularSize = 0.9f;
            star.temperatureOffset = 3.0f;
            star.uvIntensity = 1.3f;
            star.skyTintModifier = glm::vec3(0.95f, 0.97f, 1.05f);
            star.twilightDuration = 0.9f;
            break;
        case StarSpectralClass::F_YELLOW_WHITE:
            star.color = glm::vec3(1.0f, 0.98f, 0.9f);
            star.intensity = 1.1f;
            star.temperature = 6500.0f;
            star.angularSize = 0.95f;
            star.temperatureOffset = 1.0f;
            star.uvIntensity = 1.1f;
            star.skyTintModifier = glm::vec3(1.0f, 1.0f, 0.98f);
            star.twilightDuration = 1.0f;
            break;
        case StarSpectralClass::G_YELLOW:
            star.color = glm::vec3(1.0f, 0.95f, 0.85f);
            star.intensity = 1.0f;
            star.temperature = 5778.0f;
            star.angularSize = 1.0f;
            star.temperatureOffset = 0.0f;
            star.uvIntensity = 1.0f;
            star.skyTintModifier = glm::vec3(1.0f, 1.0f, 1.0f);
            star.twilightDuration = 1.0f;
            break;
        case StarSpectralClass::K_ORANGE:
            star.color = glm::vec3(1.0f, 0.85f, 0.6f);
            star.intensity = 0.8f;
            star.temperature = 4500.0f;
            star.angularSize = 1.1f;
            star.temperatureOffset = -5.0f;
            star.uvIntensity = 0.6f;
            star.skyTintModifier = glm::vec3(1.05f, 0.95f, 0.85f);
            star.twilightDuration = 1.2f;
            break;
        case StarSpectralClass::M_RED_DWARF:
            star.color = glm::vec3(1.0f, 0.6f, 0.4f);
            star.intensity = 0.5f;
            star.temperature = 3000.0f;
            star.angularSize = 1.3f;
            star.temperatureOffset = -15.0f;
            star.uvIntensity = 0.2f;
            star.skyTintModifier = glm::vec3(1.1f, 0.85f, 0.7f);
            star.twilightDuration = 1.5f;
            break;
        case StarSpectralClass::BINARY_SYSTEM:
            star.color = glm::vec3(1.0f, 0.95f, 0.9f);
            star.intensity = 1.5f;
            star.temperature = 6000.0f;
            star.angularSize = 0.8f;
            star.dayLengthModifier = 0.8f;  // Shorter day due to two suns
            star.temperatureOffset = 5.0f;
            star.uvIntensity = 1.5f;
            star.skyTintModifier = glm::vec3(1.0f, 1.0f, 0.95f);
            star.twilightDuration = 1.3f;  // Longer twilight with two suns
            break;
        case StarSpectralClass::RED_GIANT:
            star.color = glm::vec3(1.0f, 0.5f, 0.3f);
            star.intensity = 0.7f;
            star.temperature = 3500.0f;
            star.angularSize = 3.0f;  // Much larger in sky
            star.temperatureOffset = -8.0f;
            star.uvIntensity = 0.3f;
            star.skyTintModifier = glm::vec3(1.15f, 0.8f, 0.6f);
            star.twilightDuration = 2.0f;
            break;
        case StarSpectralClass::WHITE_DWARF:
            star.color = glm::vec3(0.95f, 0.95f, 1.0f);
            star.intensity = 0.3f;
            star.temperature = 10000.0f;
            star.angularSize = 0.3f;  // Very small
            star.temperatureOffset = -25.0f;  // Cold world
            star.uvIntensity = 2.5f;  // High UV despite low light
            star.skyTintModifier = glm::vec3(0.9f, 0.9f, 1.1f);
            star.twilightDuration = 0.5f;
            break;
    }

    // Add seed-based variation within type
    uint32_t varSeed = PlanetSeed::getSubSeed(seed, 1);
    float variation = PlanetSeed::seedToRange(varSeed, -0.1f, 0.1f);
    star.intensity += variation;
    star.temperatureOffset += variation * 5.0f;

    return star;
}

StarType StarType::sunLike() {
    StarType star;
    star.spectralClass = StarSpectralClass::G_YELLOW;
    star.color = glm::vec3(1.0f, 0.95f, 0.85f);
    star.intensity = 1.0f;
    star.temperature = 5778.0f;
    return star;
}

StarType StarType::redDwarf() {
    StarType star;
    star.spectralClass = StarSpectralClass::M_RED_DWARF;
    star.color = glm::vec3(1.0f, 0.6f, 0.4f);
    star.intensity = 0.5f;
    star.temperature = 3000.0f;
    star.temperatureOffset = -15.0f;
    star.skyTintModifier = glm::vec3(1.1f, 0.85f, 0.7f);
    return star;
}

StarType StarType::blueGiant() {
    StarType star;
    star.spectralClass = StarSpectralClass::O_BLUE_GIANT;
    star.color = glm::vec3(0.6f, 0.7f, 1.0f);
    star.intensity = 2.0f;
    star.temperature = 30000.0f;
    star.temperatureOffset = 15.0f;
    star.uvIntensity = 3.0f;
    star.skyTintModifier = glm::vec3(0.8f, 0.9f, 1.2f);
    return star;
}

StarType StarType::binarySystem() {
    StarType star;
    star.spectralClass = StarSpectralClass::BINARY_SYSTEM;
    star.color = glm::vec3(1.0f, 0.95f, 0.9f);
    star.intensity = 1.5f;
    star.temperature = 6000.0f;
    star.dayLengthModifier = 0.8f;
    star.temperatureOffset = 5.0f;
    star.twilightDuration = 1.3f;
    return star;
}

// ============================================================================
// RegionConfig Implementation
// ============================================================================

RegionConfig RegionConfig::fromSeed(uint32_t seed, int regionId) {
    RegionConfig config;
    config.regionId = regionId;
    config.name = "Region " + std::to_string(regionId + 1);

    // Vary biome weights
    config.desertWeight = PlanetSeed::seedToRange(PlanetSeed::getSubSeed(seed, 0), 0.5f, 2.0f);
    config.forestWeight = PlanetSeed::seedToRange(PlanetSeed::getSubSeed(seed, 1), 0.5f, 2.0f);
    config.tundraWeight = PlanetSeed::seedToRange(PlanetSeed::getSubSeed(seed, 2), 0.5f, 2.0f);
    config.tropicalWeight = PlanetSeed::seedToRange(PlanetSeed::getSubSeed(seed, 3), 0.5f, 2.0f);
    config.wetlandWeight = PlanetSeed::seedToRange(PlanetSeed::getSubSeed(seed, 4), 0.5f, 2.0f);
    config.mountainWeight = PlanetSeed::seedToRange(PlanetSeed::getSubSeed(seed, 5), 0.5f, 2.0f);
    config.volcanicWeight = PlanetSeed::seedToRange(PlanetSeed::getSubSeed(seed, 6), 0.3f, 1.5f);
    config.coastalWeight = PlanetSeed::seedToRange(PlanetSeed::getSubSeed(seed, 7), 0.5f, 1.5f);

    // Climate overrides
    config.temperatureOffset = PlanetSeed::seedToRange(PlanetSeed::getSubSeed(seed, 8), -10.0f, 10.0f);
    config.moistureMultiplier = PlanetSeed::seedToRange(PlanetSeed::getSubSeed(seed, 9), 0.5f, 1.5f);

    // Evolution biases
    config.evolutionBias.sizeBias = PlanetSeed::seedToRange(PlanetSeed::getSubSeed(seed, 10), 0.7f, 1.5f);
    config.evolutionBias.speedBias = PlanetSeed::seedToRange(PlanetSeed::getSubSeed(seed, 11), 0.7f, 1.5f);
    config.evolutionBias.aggressionBias = PlanetSeed::seedToRange(PlanetSeed::getSubSeed(seed, 12), 0.5f, 2.0f);
    config.evolutionBias.predationPressure = PlanetSeed::seedToRange(PlanetSeed::getSubSeed(seed, 13), 0.5f, 2.0f);

    // Isolation
    config.isolationLevel = PlanetSeed::seedToRange(PlanetSeed::getSubSeed(seed, 14), 0.1f, 0.9f);
    config.allowsMigration = PlanetSeed::seedToFloat(PlanetSeed::getSubSeed(seed, 15)) > 0.3f;

    return config;
}

RegionConfig RegionConfig::tropical() {
    RegionConfig config;
    config.name = "Tropical Paradise";
    config.tropicalWeight = 2.0f;
    config.wetlandWeight = 1.5f;
    config.tundraWeight = 0.1f;
    config.temperatureOffset = 8.0f;
    config.moistureMultiplier = 1.5f;
    config.vegetationDensity = 1.5f;
    config.evolutionBias.flyingBias = 1.3f;
    config.evolutionBias.bioluminescenceChance = 0.1f;
    return config;
}

RegionConfig RegionConfig::arctic() {
    RegionConfig config;
    config.name = "Frozen Wastes";
    config.tundraWeight = 2.5f;
    config.desertWeight = 0.5f;
    config.tropicalWeight = 0.1f;
    config.temperatureOffset = -15.0f;
    config.moistureMultiplier = 0.7f;
    config.vegetationDensity = 0.4f;
    config.evolutionBias.sizeBias = 1.5f;  // Larger for warmth
    config.evolutionBias.aquaticBias = 1.3f;
    return config;
}

RegionConfig RegionConfig::volcanic() {
    RegionConfig config;
    config.name = "Volcanic Lands";
    config.volcanicWeight = 3.0f;
    config.mountainWeight = 2.0f;
    config.forestWeight = 0.3f;
    config.temperatureOffset = 5.0f;
    config.vegetationDensity = 0.5f;
    config.evolutionBias.venomChance = 0.15f;
    config.evolutionBias.resourceScarcity = 1.5f;
    return config;
}

RegionConfig RegionConfig::competitive() {
    RegionConfig config;
    config.name = "Contested Territory";
    config.evolutionBias.aggressionBias = 1.8f;
    config.evolutionBias.predationPressure = 2.0f;
    config.evolutionBias.speedBias = 1.3f;
    config.evolutionBias.intelligenceBias = 1.3f;
    config.evolutionBias.resourceScarcity = 1.5f;
    config.isolationLevel = 0.2f;  // Well connected
    return config;
}

// ============================================================================
// MultiRegionConfig Implementation
// ============================================================================

const RegionConfig* MultiRegionConfig::getRegionForIsland(int islandId) const {
    for (const auto& region : regions) {
        for (int id : region.islandIds) {
            if (id == islandId) {
                return &region;
            }
        }
    }
    return nullptr;
}

MultiRegionConfig MultiRegionConfig::fromArchipelago(uint32_t seed, int islandCount) {
    MultiRegionConfig config;
    config.enabled = islandCount > 1;

    if (!config.enabled) {
        // Single island = single region
        RegionConfig defaultRegion;
        defaultRegion.regionId = 0;
        defaultRegion.name = "Main Island";
        defaultRegion.islandIds.push_back(0);
        config.regions.push_back(defaultRegion);
        return config;
    }

    // Determine number of regions (1-4 based on island count)
    int regionCount = std::min(4, std::max(1, islandCount / 3));

    // Create regions
    for (int r = 0; r < regionCount; ++r) {
        uint32_t regionSeed = PlanetSeed::getSubSeed(seed, r * 100);
        RegionConfig region = RegionConfig::fromSeed(regionSeed, r);

        // Give region a thematic name based on its characteristics
        if (region.tundraWeight > 1.5f) {
            region.name = "Northern Reaches";
        } else if (region.tropicalWeight > 1.5f) {
            region.name = "Tropical Archipelago";
        } else if (region.volcanicWeight > 1.5f) {
            region.name = "Ring of Fire";
        } else if (region.forestWeight > 1.5f) {
            region.name = "Verdant Isles";
        } else {
            region.name = "Central Waters";
        }

        config.regions.push_back(region);
    }

    // Assign islands to regions (round-robin with variation)
    for (int i = 0; i < islandCount; ++i) {
        int regionIndex = i % regionCount;
        config.regions[regionIndex].islandIds.push_back(i);
    }

    // Set migration rate based on total islands
    config.globalMigrationRate = 0.05f + 0.02f * static_cast<float>(islandCount);
    config.competitiveMode = islandCount >= 6;  // Enable competition tracking for larger worlds

    return config;
}

// ============================================================================
// VegetationDensityConfig Implementation
// ============================================================================

VegetationDensityConfig VegetationDensityConfig::fromSeed(uint32_t seed) {
    VegetationDensityConfig config;

    // Determine preset from seed
    float presetValue = PlanetSeed::seedToFloat(seed);
    if (presetValue < 0.15f) {
        config = sparse();
    } else if (presetValue < 0.6f) {
        // Default - keep defaults
    } else if (presetValue < 0.85f) {
        config = lush();
    } else if (presetValue < 0.92f) {
        config = alien();
    } else if (presetValue < 0.97f) {
        config = overgrown();
    } else {
        config = dead();
    }

    // Add seed-based variation to the preset
    config.treeDensity *= PlanetSeed::seedToRange(PlanetSeed::getSubSeed(seed, 1), 0.9f, 1.1f);
    config.grassDensity *= PlanetSeed::seedToRange(PlanetSeed::getSubSeed(seed, 2), 0.9f, 1.1f);
    config.flowerDensity *= PlanetSeed::seedToRange(PlanetSeed::getSubSeed(seed, 3), 0.8f, 1.2f);

    return config;
}

VegetationDensityConfig VegetationDensityConfig::sparse() {
    VegetationDensityConfig config;
    config.preset = VegetationPreset::SPARSE;
    config.treeDensity = 0.3f;
    config.grassDensity = 0.4f;
    config.flowerDensity = 0.2f;
    config.shrubDensity = 0.3f;
    config.alienPlantDensity = 0.0f;
    return config;
}

VegetationDensityConfig VegetationDensityConfig::lush() {
    VegetationDensityConfig config;
    config.preset = VegetationPreset::LUSH;
    config.treeDensity = 1.5f;
    config.grassDensity = 1.4f;
    config.flowerDensity = 1.6f;
    config.shrubDensity = 1.5f;
    config.alienPlantDensity = 0.0f;
    return config;
}

VegetationDensityConfig VegetationDensityConfig::alien() {
    VegetationDensityConfig config;
    config.preset = VegetationPreset::ALIEN;
    config.treeDensity = 0.8f;
    config.grassDensity = 0.6f;
    config.flowerDensity = 0.4f;
    config.shrubDensity = 0.5f;
    config.alienPlantDensity = 1.2f;  // High alien plant density
    config.biomeDensityVariation = 0.4f;  // More variation
    return config;
}

VegetationDensityConfig VegetationDensityConfig::dead() {
    VegetationDensityConfig config;
    config.preset = VegetationPreset::DEAD;
    config.treeDensity = 0.1f;
    config.grassDensity = 0.15f;
    config.flowerDensity = 0.05f;
    config.shrubDensity = 0.1f;
    config.alienPlantDensity = 0.0f;
    return config;
}

VegetationDensityConfig VegetationDensityConfig::overgrown() {
    VegetationDensityConfig config;
    config.preset = VegetationPreset::OVERGROWN;
    config.treeDensity = 2.0f;
    config.grassDensity = 1.8f;
    config.flowerDensity = 1.5f;
    config.shrubDensity = 2.0f;
    config.alienPlantDensity = 0.2f;
    return config;
}

// ============================================================================
// WorldGenConfig Implementation
// ============================================================================

void WorldGenConfig::applyVariationFromSeed() {
    if (seed == 0) return;

    PlanetSeed ps(seed);

    // Apply star type from seed if randomization enabled
    if (randomizeStarType) {
        starType = StarType::fromSeed(ps.paletteSeed);
    }

    // Apply vegetation config from seed
    vegetationConfig = VegetationDensityConfig::fromSeed(ps.vegetationSeed);

    // Vary erosion and noise parameters from terrain seed
    auto terrainVar = SeedVariation::TerrainVariation::fromSeed(ps.terrainSeed);
    erosionPasses = 2 + static_cast<int>(terrainVar.erosionStrength * 5.0f);
    erosionStrength = terrainVar.erosionStrength;
    noiseOctaves = 4 + static_cast<int>(terrainVar.noiseFrequency * 4.0f);
    noiseFrequency = 0.5f + terrainVar.noiseFrequency;
}

// ============================================================================
// World Output Getters Implementation
// ============================================================================

std::string ProceduralWorld::getThemeName() const {
    if (m_currentWorld) {
        return m_currentWorld->themeName;
    }
    return "Unknown";
}

float ProceduralWorld::getGenerationTimeMs() const {
    if (m_currentWorld) {
        return m_currentWorld->generationTimeMs;
    }
    return 0.0f;
}

float ProceduralWorld::getTerrainScale() const {
    return m_lastConfig.terrainScale;
}

float ProceduralWorld::getWaterLevel() const {
    if (m_currentWorld) {
        return m_currentWorld->waterPercentage / 100.0f;
    }
    return 0.0f;
}

ProceduralWorld::BiomeDistribution ProceduralWorld::getBiomeDistribution() const {
    BiomeDistribution dist;
    if (m_currentWorld) {
        dist.desertPercentage = m_currentWorld->desertCoverage;
        dist.forestPercentage = m_currentWorld->forestCoverage;
        dist.grasslandPercentage = 0.0f;  // Not tracked separately yet
        dist.tundraPercentage = m_currentWorld->tundraCoverage;
        dist.wetlandPercentage = m_currentWorld->wetlandCoverage;
        dist.mountainPercentage = m_currentWorld->mountainCoverage;
        dist.volcanicPercentage = 0.0f;   // Part of mountain coverage
        dist.oceanPercentage = m_currentWorld->waterPercentage;
    }
    return dist;
}
